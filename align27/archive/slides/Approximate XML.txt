Approximate XML Query Answers
Neoklis Polyzotis (UC Santa Cruz)
Minos Garofalakis (Bell Labs)
Yannis Ioannidis (U. of Athens, Hellas)

Represented by: Gal Zach


Motivation
XML: de-facto standard for data exchange over the Internet.
Conflict between “on-line” and query execution cost
Increased query response times
Users might wait for un-interesting results
Processing  the query over a concise synopsis of the XML data.
The approximate result should be:
Computed fast 
Similar in its value content to the true result
Similar in its hierarchical structure to the true result


Outline
Motivation
Background: Synopsis model
TreeSketch Synopses
Summarization model  Structural clustering of elements
Efficient processing and construction
Element Simulation Distance
Experimental Results

Twig Query - Example
for q1 in //a[//b]
      for q2 in q1//p
return
     q1//n,
     for q3 in q2//k
     return q3
q0
q1
q2
q3
q4
//a[//b]
//p
//k
//n
a
p
k
n
a
p
k
n
d
Twig query
Query tree
Nesting tree
b
The           is for the paths that are specified in the return clause.

Synopsis Model
Let G =(VG,EG) a direct node-labeled graph.
A graph synopsis S(G)= (VS,ES) is a direct node-labeled graph where:
Each Node vVS corresponds to a subset of element (or attribute) node in VG, termed the extent of v – extent(v), that have the same label. 

An edge (u,v)EG is represented in ES as an edge between nodes whose extent contains the two endpoints u and v.
Each synopsis node u store a tag tag(u) for the common tag of its element and a count field |u| for the size of its extent.

Synopsis Model
Synopsis node  Set of elements of the same tag


 
Synopsis edge  Document edge(s)

r
a(3)

XML Data Graph
                  


P0      
PB3     
A1      
A2      
N4      
N8      
V8      
V4      
E14      
P6
F13     
B5      
F10      
P7      
B9      
T12      
V10      
V11      
V12      
V13      
V14      
T11     
Synopsis Model - Example
P(1)
A(2)
PB(1)
N(2)
P(2)
T(2)
B(2)
F(2)
E(1)
Count(A) = | Extent(A) | 
                 =  | {A1,A2} | =2 
Synopsis graph

Example for Twig-XSketch 
Document T1
Twig-XSketch
B/F=Backward forward

Document T2
Note: The numbers on the edges represent how many edges are of this kind.

Count-Stability and theTreeSketch Synopsis

Definitions
Let R  V x V denote an equivalence relation over the nodes of T(V,E), and let (u,v) denote a pair of equivalence classes (i.e. element node partition) induced by R.
The pair (u,v) is K-stable (K≥0) iff each element eu has exactly k child elements in v.
The relation R and the graph synopsis SR(T) resulting from the corresponding element partition are said to be count stable iff for every possible pair of element partitions (u,v) there exists some k≥0 such that (u,v) is k-stable.

Examples
Tree T1
SR(T1)
 The pair (r, a) is 2-stable.
 The pair (a, b) is not k-stable for any k≥0.
Tree T2
SR(T2)
 The pair (r, a) is 2-stable.
 The pair (a, b) is 3-stable.
 SR(T2) is count-stable.

Lemma
Given a data tree T(V,E) there exists a unique minimal (in terms of the number of equivalence classes) count-stable equivalence relation R V x V.
Furthermore, there exists a function Expand from stable relations to XML trees, such that Expand(R) is isomorphic to the original document tree T.

Example
SR(T1)
SR(T2)

TreeSketch Synopsis
TreeSketch synopsis TS for an XML data tree
T is a graph-synopsis for T where:

Each node u in TS stores an element count  count(u) = |extent(u)|.

Each edge (u,v) in TS stores an (average) child count count(u,v) equal to the average number of children in extent(v) for each element in extent(u).

TreeSketch Synopsis
The interpretation of the stored average is simple:
All elements in the extent of u have count(u,v) child elements in the extent of v.

TreeSketches and Clustering

TreeSketches and Clustering
Let u be a synopsis node with outgoing edges 
    u   v1,…,u    vn. The set of outgoing edges defines a n-dimnetional space where an element e  u is mapped to  point (c1(e),…,cn(e)) if it has ci(e) children to node vi, 1≤ i ≤n. 
The recorded average edge counts essentially map all points in this space to point (count(u,v1),…,count(u,vn)), which actually represents the centroid of the cluster.


TreeSketches and Clustering - Example
Synopsis tree
Original tree

TreeSketches and Clustering
We can characterize the quality of a TreeSketch synopsis by using a metric that quantifies the quality of the induced clustering.
The metric used in the article is the squared error of the clustering which essentially measures the euclidean distance between points and their corresponding centroid.
The squared error of a single cluster u is defined as sq(u) = ΣeuΣ1≤ i ≤n(ci(e)-count(ui,vi))²
Sq(TS) for a synopsis TS is simply the sum of squared errors for all the induced clusters.

TreeSketches and Clustering
Note that the squared error for a count-stable synopsis is zero since all edge-count centroids are exact, i.e., the child count for any element in a given synopsis node extent are identical.
Tight clusters  Accurate synopsis
The perfect synopsis corresponds to a perfect clustering

Building the Count-Stable Summery

BUILDSTABLE Algorithm
Input: XML document T.
Output: Count-Stable synopsis S to T.
Begin
H=Ф; S=Ф
 foreach eT in post-order do
     C={(ui,ci):ui is a node in S and ci=|children(e)∩extent(ui)|>0}
     if (H[lable(e),C]=Ф) than
          Add node u to S with label(u)=label(e)
          H[lable(e),C]=u
          for (ui,ci)C do add edge u    ui to S
     endif
     u=H[lable(e),C]; extent(u)=extent(u)U{e}
 endfor
end

=>The algorithm time: O(|T|)

Example
r
a1
b2
b1
b3
a2
b’
a’
a’’
r’
1
1
1
2
T
S
H
(b, Ф) = b’
(a,{(b’,2)}) = a’

(a, {(b’,1)}) = a’’

(r,{(a’,1),(a’’,1)}) = r’

C= Ф
C= {(b’,2)}
C= Ф
C= {(b’,1)}
C= {(a’,1),(a’’,1)}
b1
b2
a1
b3
a2
r

Space Budget Limitations
Given an XML tree T, build a TreeSketch of size B
Difficult clustering problem
Space dimensionality depends on the clustering itself
Construction based on bottom-up clustering
Compress perfect synopsis by merging clusters
Best merge determined by marginal gains

Perfect 
Space Budget 
…

TSBUILD Algorithm
Maintain a pool of candidate operations for merging 2 nodes of TS in size Uh (given as input to the algorithm).
m(TS) denotes the resulting synopsis after applying merge m on TS.
m.errd = sq(m(TS)) - sq(TS) is the increase in squared error from TS to m(TS).
m.sized = size(TS) - size(m(TS)) is the decrease in synopsis size.
The operations pool is organized in min-heap according to the marginal-gain ratio m.errd / m.sized.

TSBUILD: Main Steps
Input:
XML Tree T.
Space budget S.
Upper/Lower bounds for heap size (Uh, Lh).
Output: TreeSketch synopsis TS of T of size ≤ S.
Main Steps:
TS = BuildStable(T);
Creates the pool of candidates merge operations on size Uh.
Applying each merge operation on it’s turn on TS.
After each merge, recompute all necessary parameters of TS.
If TS drops bellow size S, the algorithm stops.
If the pool size drops below the bound Lh, replenish it.

TSBUILD

CREATEPOOL Algorithm
Generate all possible pair-wise merges and keep the top Uh       O(N²) merge operations.
Key observation: Two elements have similar structure, if their children have similar structure.
Children clusters should be merged first.
Bottom-up merging, based on depth
Depth: distance from the leaves of the tree.
Build a pool of candidate merges by increasing depth.
Replenish the pool when it falls below a given threshold.

CREATEPOOL

Approximate Query Processing

EVALQUERY: Main Steps
Input:
TreeSketch TS of document T.
Twig Query Q.
Output: TreeSketch TQ that approximates the nesting tree NT(Q).
Main Steps:
Go in pre-order traversal on Q.
After qj was added, go to it’s son qi.
Add the node qiQ if it doesn’t exists yet, and calculate the paths number from qj  to it, acording to TS.
Connect qi to qj (the parent node) by adding an edge.

EVALQUERY Algorithm

EVALEMBED

Example
Query
TREESKETCH
Result TREESKETCHTSQ

Example Cont.
Let us consider the processing of node q1 (on the query), and more specifically the computation of bindings from q1 to q3.
Starting from node A, which appears in the bindings of q1, we can identify exactly one simple embedding of path(q1,q3)=d[/g]//f, namely e=A/D/F. The bindings of q3, therefore, will be the descendants of A along the given embedding.
The number of descendants for each element in A:
nt = count(A,D)·count(D,F)=2·0.5=1.
s = 0.6+0.7-0.6·0.7=0.88.
=> The number descendants along d[/g]//f for each binding q1 is 1·0.88 = 0.88.

Error of Approximation - Abstract
The error of approximation is quantified by the distance between the 2 XML trees.
The distance represents how much 2 trees are similar, by the aspects of structure and meaning.
ESD - Element Simulation Distance - is a metric described on the article which quantifies the above-mentioned distance.


Experimental Study
Data Sets:
IMDB - real-life data set from the Internet Movie Data Base.
XMark - synthetic data set that models transactions on an online-action.
SwissProt - real-life data set with annotations on proteins.
Workload: 1000 random twig queries.
Evaluation metrics:
Average ESD for approximate answers

Data Sets Characteristics

Approximate Answers
IMDB (~102K Elements)
Avg. Result Size: 3,477 tuples

Approximate Answers
XMark (~103K Elements)
Avg. Result Size: 2,436 tuples
 
.

TreeSkethces
TwigXSkethces

Approximate Answers
SwissPort (~182K Elements)
Avg. Result Size: 104,592 tuples
.

TreeSkethces
TwigXSkethces

Construction times
Construction times (minutes) for TREESKETCHes and twig-XSKETCHes.


Error of Approximation
Let NTS(Q) be the approximate nesting tree that is computed over a concise synopsis TS, and let NT(Q) be the true nesting tree of the query Q.
The error of approximation is quantified by the distance between the 2 XML trees, denoted as distA(NTS(Q), NT(Q)).
We will use the tree-edit distance metric, which measure only the syntactic differences.

Tree-edit distance metric
The tree-edit distance distE(T1,T2) between 2 XML trees measures the minimum cost sequence of edit operations the transform T1 to T2.
Operations on tree nodes (basic):
Adding
Deleting
Relabeling

Tree-edit distance metric  - Example
Query answer T
Approximation T1
Approximation T2
distE(T,T1) = 3·|Sc|+3·|Sc| = 3·|Sc|+3·|Sd|  = distE(T,T2) 

Element Simulation Distance
New distance metric for XML trees.
Considers both the overall path structure and the distribution of document edges.
Defined recursively.
Uses existing distance metric such as MAC (match and compare) and EMD (earth mover’s distance). 
	Note: these metrics are not described on the article.

Element Simulation Distance
MAC: A numerical measure to quantify the quality of an approximate answer to a set-valued query.
EMD: Measures a distance between 2 distributions, which reflects the minimal amount of work that must be performed to transform one distribution into the other by moving “distribution mass” around.


Element Simulation Distance
Let uT1 vT2 be elements of the compared trees where label(u)=label(v).
Let Ut, Vt denote the children sets of u, v respectively, that have tag t.
ESD(u’,v’) denotes the distance between any 2 elements u’Ut, v’Vt.
The distance distς(Ut, Vt) between Ut, Vt is defined by using an existing value set distance metric, like MAC or EMD.
ESD(u,v) = Σdistς(Ut, Vt) 

Element Simulation Distance
Assume without loss of generality that Vt=Ø.
For each element eUt, we insert a unique element ev in Vt with distance ESD(e,ev)=|e|, where |e| is the sub-trees size of e, and ESD(e’,ev)=∞, for all e’ Ut, e’≠e.
ESD Between two Trees :
		ESD(T1,T2) = ESD(root(T1), root(T2)).

ESD - Example
Let u,v be the left a elements of T and T1 respectively. Element u,v have children of tags c and d and thus
	ESD(u,v)= distς(Uc, Vc)+ distς(Ud, Vd).
	ESD(ci,cj), ciUc, cjVc are equal to 0, since the elements have identical sub-trees. Notice that the 2 value sets contain equal values but at different multiplicities.
	Using the MAC metric:
	distς(Uc, Vc)=8  => ESD(u,v)=8+0=8.

ESD – Example Cont.
Let v’ be the left element a of T2.  . . .  ESD(u,v’)=6.


Questions

Thank You!


