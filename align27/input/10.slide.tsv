0	Adaptive XML Storage Adaptive XML Storage or  The Importance Of Being Lazy Nihan ÖZMAN 26.10.2005 Instructor: Prof. Taflan Gündem	 
1	XML Data Building an XML store means finding solutions to the problems of representing, accessing, querying and updating XML data. Relational Database Systems rely on a fixed-schema of records to represent and manage data. Being irregular in structure and content, XML Data does not seem to allow this approach. 
2	This Paper... Describes  how the notion of database record has been extended and applied to XML storage how the resulted store abstracts the structure of the XML data from the actual storage format The contributions of the paper are: 	(a) the problem definition for XML stores 	(b) an adaptive XML store and flexible index structures based on the existence of the XML store 	(c) an evaluation of lazy/partial index 
3	Overview Problem: The irregularity of the structure and usage of XML becomes a big obstacle in achieving good performance during accesing, querying and updating XML data. New challanges Efficient query evaluation. Efficient access and retrieval of XML data. Maintainment of document order. Optimizing XML updates. 
4	Overview - 2 Existing approaches lack a uniform way of representing and thinking of XML.  focus on one aspect of XML storage and assume that the application will adapt to a particular usage pattern. function as all-or-nothing as regards indexing, where advantages gained by knowing all node information is lost in poor performance updates. So, one can not achieve everything at once, but should focus on what it can achieve at a given moment, in a given usage context. 
5	Overview - 3 This paper presents Ranges as a flat representation of desiderata for an XML store. Ranges are logical units similar to tuples in relational databases, whose size and existence is defined by the application usage patterns Ranges provides a lazy approach to storing, accessing and indexing XML data. Ranges offer enough flexibility to have application-dependent indexing units. 
6	XML Store Desiderata - 1 Requirements for an XML Store  Store and access any instances of the XQuery Data Model Support for XML Update Allow optimization of reads and/or updates Indexes Support different Node Identifer schemas (support for stable and comparable identifies) Low storage overhead Support PSVI (Post Schema Validation Infoset) 
7	XML Store Desiderata - 2 The XQuery Data Model supports a wide range of XML applications, either read-oriented or heavy-update scenarios. PSVI avoids repeated evaluation of XML schema. Low storage overhead incurs by minimizing the quantity of data actually stored. Node identifiers are assigned, according to the XQueryModel to each node in the data instance. 
8	XML Store Desiderata - 3 The store should support read operations, entire data source or a single node The store should support update operations that specify a node and allow insertions of the data relative to this node (as previous siblings, next sibling, first child or last child of the node) 
9	Optimizing Reads vs. Optimizing Updates Typical storage systems are faced with challenges of optimizing read operations or update operations required by the application A store that achieves both optimality is a utopia. (Ex: The structures required to support read operations, fast indexes, negatively influence the performance of update operations) In the paper, a middle approach is taken for optimizing one or the other depending on the application load. 
10	XML Representation The requirements for XML store have been fulfilled in the particular case of an XML store. There are 3 important choices: the XML representation the definition of an arbitrarily granular unit Range the flexible index structures based on the existence of Range   
11	Choosing an XML Representation For representing or storing, XML Data is either shredded on a relational database, special index structures or the combination of the two There is usually a strong relationship between storing and representing XML on one side, indexing and querying it on the other side. Current approaches do not seperate them. The adaptivity requirement in this paper’s approach provides both data independence and flexible granularity.   
12	A Flexible Representation - 1 To denote each part of the XQuery Data Model, Tokens, that are a materialization of enriched SAX (Simple API for XML) events, are used. Nodes in the XQuery Data Model, who must have an associated identifier, are also represented by a sequence of tokens 
13	A Flexible Representation - 2 This representation of the XQuery Data Model offers : Complete representation of the XQuery Data Model Independence of the API used in the actual application (flat model as opposed to tree-based or event-based representation) Allows flexible data granularity (Token is the most granular unit and tokens can be grouped in more specific units) Post schema validation info set (Token sequence can also be associated to the XML schema type derived after a schema validation)  
14	Storage Model - 1 The storage model of the XML data in the store presented consists of token sequences serialized in sequential blocks/pages in document order. Tokens offer a flat representation of the XML data, independent of the actual data model of the application that uses the store.   
15	Storage Model - 2 For example, each time data is inserted in the store: the corresponding tokens are generated and stored in the corresponding positions in the storage. blocks are allocated accordingly. Node Ids, requested in the XQuery DataModel are generated. 
16	Implementing Database Records for XML The interface to the store defines read, insert and update operations. All operations are defined relative to a target node identifier. So, it is nodes corresponding to these identifiers that need to be quickly located. Existing approaches to XML data storage take the options of full data indexing in order to optimize queries and accelerate access to specific parts of XML data. In this way, updates are too expensive.   
17	Discarding the Option of A Full Index The advantage of a full index is the ability to quickly locate nodes. On the other hand, it has main disadvantages: inserts and updates are more expensive storage requirements are very high the index grows in size for data-intensive applications and the vast majority of the entries will not even be used.  
18	The Notion of Range Range is a sequence of tokens. Each sequence of tokens can constitute a range. In presented model, a Range is implemented as a sequence of variable-sized tokens, where in  relational database systems, a Record is implemented as a sequence of variable-sized fields. Range is defined by the usage pattern of the application, not by a fixed schema. An order between Ranges is needed to preserve document order of tokens.   
19	The Range Index (Coarse-Grained Index) The Range index is for locating the range corresponding to an ID specified in an update operation. Ranges represents insert units where full index would have contained all IDs individually. Range index contains less entries, it refers to an interval of identifiers. Node identifiers need not to be stored together with the tokens they refer to. The advantage is better space utilization (low storage overhead).   
20	The Storage Model Ranges are the logical storage units. Storage level comprises chained blocks, which, at their turn, contain ordered ranges. Document order is preserved through the chaining of blocks and through the ordering of ranges inside blocks. 
21	Functionality of the Range Index A Simple Usage Scenario - 1 There is an initially empty Data Source. The operations performed: (1) insert 2 sibling Nodes (contains 100 nodes in total) (2) insert a child (40 nodes) as the last child of the node which is identified by 60:  	insertIntoLast(60,<<new data>>) Tokens are created for the inserted data, and they are stored sequentially on the pages. Node IDs are created, but only the ranges are inserted in the Range Index.  
22	Functionality of the Range Index A Simple Usage Scenario - 2 Effects of each step on the Range Index: (1) Allocate 100 identifiers for the inserted nodes, create range 1 with Ids 1-100 and store it in Block 1. (2) insertion of the child: (2a) Locate second node using the Range Index (id is in range 1) (2b) Locate range and offset of the end token of the node with the Id 60 (2c) Split range number 1 in two (create range 3) (2d) Create a new range corresponding to the inserted data (2) and allocate 40 unique identifiers.   
23	Functionality of the Range Index A Simple Usage Scenario - 3 (2e) Store the new range (Block 1) and insert the split range in the storage (Blocks 2) 
24	The Lazy/Partial Index - 1 The notion of Range and Range Index allows to optimize update operations (fewer entries are inserted to the range index). By the way, reads become more expensive. Nodes can not be accessed directly and additional lookups need to be performed. The solution is the notion of Partial Index: using the advantages of the full index, but only when needed. 
25	The Lazy/Partial Index - 2 The result of lookup operations, performed during updates, is inserted in the partial index, either: the range of a token the offset of a token inside its range the location (range, offset) of the end token of the node inside the range the position of the end token of the node inside. The partial index stores information on the individual nodes: their exact ranges and offset inside the range. 
26	The Lazy/Partial Index - 3 The partial index is actually a combination between a real index and a cache. The combination of the Range Index and the Partial Index achieves the goal of being adaptive, flexible and lazy in XML world The aim is not to index everything, but only if and when needed. 
27	The Lazy/Partial Index - 4 Referring to the previous example: (1) Considered empty at the beginning, inserting on empty data source does not create entries in partial index (2) Inserting a new node (2a) Locating node with Id 60 using the range index in range 1: a new entry is inserted in the partial index to indicate the range  (2b) Locating the end token of the id 60,means that after the insert, the location of the end token is the range 3. 
28	Orthogonality of ID Schemes Indexing XML data relies heavily on the fact that nodes in an XML document are assigned an identifier update operations are expressed based on these identifiers indexes can be build on top of them. Proposed model provides a separation from the API of the application: a range can span over several nodes, or over parts of a node (represented as a sequence of tokens) Ids of nodes are, orthogonal to the way of indexing. 
29	Low Storage Overhead - 1 The Range Index is a coarse-grained index (lower storage overhead over full index) The Range Index uses properties of Ids for locating the range of a node with the given id {ID} is the set of Node identifiers in the store {R} is the set of all ranges in the Range Index 
30	Low Storage Overhead - 2 A Range is defined as a sequence of tokens in document order. By only storing the Identifiers of the first node inside a range, further decrease storage overhead can be obtained.  The Id schemes with this property generate the Id of the next token ID using a simple factory function: 
31	Stable and Comparable Identifiers Stable identifiers are the way to build indexes on the store: external and based on logical node identifiers. Stable identifiers can be obtained by assigning unique integer number to nodes at insert times This approach allows to define actual ranges of Ids Ids inside ranges are comparable Ids inside ranges A semi-stable document order at read time can be obtained (tokens are stored in document order and read sequentially) The combination of order between ranges and order of ranges in the storage, can also be put in connection to partially-stable identifier schemes. 
32	Experiments Experimental Setup: Based-on relational database, Java and JDBC used Pentium 4 2,8Ghz/512MB RAM, running SuSe Linux9.0, and using a MySQL 
33	Predictions The identifier scheme associates unique integer values to each node, at insert time. Only ranges become entries in the index. A memory-based partial index adds information on the location of tokens inside ranges (begin and end token) 
34	Parameters The parameters that influence the results of benchmark: size of the ranges number of the ranges A course-grained index means low update overhead but large overhead at read and lookup. An index containing many entries leads to performance decrease at insert time. The partial index improves reads especially in the case of more coarse-granular range sizes, as it builds entries lazily (cache-like) 
35	Micro Benchmarks inserts, sequential reads random reads of small pieces of data in the presence of a  full index,  range index,  respectively the combination of range index + partial index The metric is kilobytes/second (read speed, relative to data size). 
36	Experimental results: Lazy indexing in XML storage 
37	Results The results reflect the expected behavior The Range Index clearly brings advantages in what regards update speed: less entries are entered the index As the number of entries increases, the advantages diminish (many,granular entries) The Partial Index helps to achieve cheaper reads and lookups  (especially when the range index is coarse) More optimizations of the read/update/storage overhead is considered. 
38	Related Work Abstraction of tree model of the XML data is used to define partial indexes. Usage of variable-size range and varying granularity are not entirely contained. Logic identifiers have not been studied 
39	Conclusions And Future Work The paper describes a data representation and model of an XML store, inspired by the notion of records in relational databases. 
40	Advantages Independence of proposed data format from the API used by the XML application The possibility to adapt to the application pattern The store achieves this by  lazily creating its storage and index structures optimizes for reads or updates according to how the application focuses on one or the other.  the process is transparent to the application. 
41	Aspects To Explore The effect of functionality of the partial index Structural properties of the actual elements of the XQuery DataModel Concurrency Non-relational world the principles of storage already defined in the context by relational database systems, The issue that differs from the relational world is the necessity to always maintain the order between ranges 
