0	Adaptive Stream Filters for Entity-based Queries with Non-value ToleranceVLDB 2005 
1	Data Streams and Applications Data Stream Management Systems (DSMS) Sensor networks, location-based applications STREAM [ABB03], STEAM [HAFME03], AURORA [ACC03], CACQ [MSH02] Stream applications Telecom call records Network security [BO03] Habitat monitoring [MPS02] Structural health monitoring Continuous Queries 
2	DSMS Model User Query Processing Unit Central Processor Continuous Query Result (Refreshed  if needed) stream stream stream stream Network Real-time, Response Time requirement Massive, Fast Limited memory, CPU, network bandwidth 
3	Trading Accuracy for Query Timeliness A user may accept an answer with a carefully controlled error tolerance  wide-area resource accounting load-balancing in replicated servers The system exploits error tolerance to reduce communication and computation costs 
4	Value-based Tolerance Often assumed in literature [OJW03, JCW04] Maximum error is a numerical value  specified by user MAX Query: Return sensor id with the highest temperature Guarantee the sensor id returned has temperature value not lower than  from that of the true answer 
5	Is Selecting  Easy? Location-based application: a user inquires about his closest neighbor Should the tolerance be 0.1, 1, or 100 meters? Sensor network collects humidity, temperature, UV-index, wind speed Does user know the range of error for each type? Multi-dimensional data streams (e.g., location)  Multimedia data streams (e.g., CCTV images) 
6	Is Selecting  for MAX Query easy? Suppose a user accepts an object that ranks 2nd or above. small If  is too small…… large If  is too large…… ideal The ideal …… Tolerance  wasted Error unacceptable 
7	Rank-based Tolerance Express error tolerance as a rank Error tolerance = no. of positions the returned sensor could rank below the highest one More intuitive and easier to specify Rank-based tolerance = 1 
8	Non-Value Tolerance Rank-based tolerance is non-value- tolerance numerical value  not used Fraction-based Tolerance False Positive F+(t): % of returned answers that are incorrect at time t False Negative F-(t): % of correct answers not returned at time t F+(t) ≤ +; F-(t) ≤ - 
9	Entity-based Queries Return sets of object ids, not numerical values [CKP03] Rank-based queries: order of stream values decides the final answer e.g., top-k query, k-nearest-neighbor query Non-rank-based queries: order of stream values is not important e.g., range query Non-value tolerance matches entity-based queries!  
10	Continuous Query Classification 
11	Adaptive Filter [OJW03]: Initialization Phase Constraint Assignment Unit Data Stream  1 Filter Bounds User-defined Tolerance Data Stream  2 Data Stream 3 [l3,u3] [l2,u2] [l1,u1] Answer tolerance is met  as long as  no update is generated Query  Processing Unit Approximate Answer 
12	Adaptive Filter: Maintenance Phase Constraint Assignment Unit New Filter Bound User-defined Tolerance Update (v2>u2 or v2 < l2)  Data Stream  1 (v1) Data Stream  2 (v2) Data Stream 3 (v3) [l3,u3] [l2,u2] [l1,u1] [l2,u2] Request Value v3 Tolerance violated! trigger Maintenance Phase Query  Processing Unit Approximate Answer Corrected Approximate Answer 
13	Contributions Apply filter bounds to rank-based / non-rank-based queries subject to  rank-based / fraction-based tolerance to reduce  message costs Correctness proofs, cost analysis and experimental evaluation of each protocol 
14	Filter Bound Protocols RTP FT-RP FT-NRP ZT-RP ZT-NRP 
15	Non-Rank-based Queries S6 S5 S2 S7 S4 S8 S1 S3 Ordered Values Answer Set Example: 1D Range Query 2        6          11         14                           23     25             34                41   Range  = [10, 30] 
16	Fraction-based Tolerance S6 S5 S2 S7 S4 S8 S1 S3 Range of Q = [l, u] Ordered Values Update Update False Positive False Negative 
17	Fraction-based Tolerance Answer actually returned A(t) E+(t) True answer at time t |A(t)|-E+(t) E-(t) = |A(t)| - E+(t) + E-(t)  
18	Initialization Phase Given ε+ and ε-  Collect current stream values For streams satisfying the range query Calculate no. of streams (Emax+) that can be false positives Assign false +ve filters [-∞, + ∞] to Emax streams  Assign [l,u] to remaining ones For streams failing the range query Calculate no. of streams (Emax-) that can be false negatives Assign false -ve filters [+∞, +∞] to Emax- streams Assign [l,u] to remaining ones Tolerance is satisfied if no new updates are received At any time t without update, F+(t) ≤ + F-(t) ≤ - 
19	Maintenance Phase: Good Update S6 S5 S2 S7 S4 S8 S1 S3 Insert S7  into A(tc) F+ and F- drop F+(tc) < F+(t0) ≤ +  F-(tc) < F-(t0) ≤ - Tolerance is met  time tc time t0 Filter [l,u] Range of Q = [l, u] 
20	Maintenance Phase: Bad Update Remove Si from A(tc) F + (tc) ≤ + and F - (tc) ≤ -  may not be true Quality of answer becomes worse Procedure Fix to maintain tolerance S6 S5 S2 S4 S8 S1 S3 time tc time t0 Filter [l,u] Range of Q = [l, u] S7 
21	Fix: Consulting False Positive Filter S6 S5 S2 S7 S4 S8 S1 S3 Select stream S4 A(tc) with [-∞, +∞] filter  Request S4 for its updated value If V4  [l, u] install [l, u] filter to S4 prove that F +(tc) ≤ + and F - (tc) ≤ - are satisfied If V4  [l, u], consult a false –ve filter Worst case: 5 messages   Filter [-∞, +∞] Range of Q = [l, u] 
22	Filter Bound Protocols for Rank-based Queries k-NN query is a representative of NN, Min, Max Fraction-based tolerance / k-NN query View a k-NN query as a range query, by using the kth nearest neighbor as the “range” Adapt fraction-based tolerance/range query Rank-based tolerance / k-NN query Maintain knowledge about (k+r)th and (k+r+1)st item Filter bound is defined by the average of the (k+r)th and (k+r+1)st item 
23	Experiments Compare No filter is used at all Filter protocols with zero tolerance Our tolerance-based protocols Measure total no. of messages required for executing a continuous query 
24	Experimental Setup Real Data 30 days of wide-area traces of TCP connections based on TCP trace [ITA20] Synthetic Data Generated by CSIM 18 Data value: Uniform distribution Fluctuation of updates: Normal distribution Interarrival time of updates: Exponential distribution 
25	Fraction-based Tolerance for Range Query with Real Data 
26	Fraction-based Tolerance for Range Query with Synthetic Data 
27	Conclusions Value-based tolerance can be difficult to specify for continuous queries in stream systems Rank-based and fraction-based tolerance Applied to rank- queries and non-rank- queries Filter bound protocols translate non-value- tolerance to filter bounds Experiments illustrate protocol effectiveness Please contact Reynold Cheng (csckcheng@comp.polyu.edu.hk) for details 
28	Contact Information Reynold Cheng Hong Kong Polytechnic University Email: csckcheng@comp.polyu.edu.hk http://www.comp.polyu.edu.hk/~csckcheng 
29	Issues of Running Out of Filters If all false positive and false negative filters run out, the system degrades to one in which no tolerance is exploited To improve performance, initialization phase may be executed again Experiments over long-running queries 
30	Long-Running Queries 
31	Talk Outline Non-value-based Tolerance Filter Bound Framework Filter Bound for Fraction-based Tolerance for Non-rank-based Queries  Experimental Results Conclusions 
32	Talk Outline Non-value-based Tolerance Filter Bound Framework Filter Bound for Fraction-based Tolerance for Non-rank-based Queries  Experimental Results Conclusions 
33	Talk Outline Non-value-based Tolerance Filter Bound Framework Filter Bound for Fraction-based Tolerance for Non-rank-based Queries  Experimental Results Conclusions 
34	Tolerance & Filter Bounds [OJW03] User Query Processing Unit Processor Continuous Query + Tolerance Result with Error Guarantee Constraint Assignment Unit stream stream stream stream dropped data constraint Filter bound [l,u] [l,u] [l,u] Update sent only when value crosses [l,u] 
35	Fraction-based Tolerance Answer actually returned A(t) E+(t) True answer at time t |A(t)|-E+(t) E-(t) = |A(t)| - E+(t) + E-(t)  
36	Zero Tolerance S6 S5 S2 S7 S4 S8 S1 S3 Update Update 
37	Zero-Tolerance Protocol (ZT-NRP) Given a range query [l,u] Initialization Phase Emit [l,u] to each stream source Maintenance Phase For any stream source, if its value crosses [l,u], send its new value to the server No message from server is needed  Generates a lot of updates! 
38	Fix: Consulting False Positive Filter S6 S5 S2 S7 S4 S8 S1 S3 Filter [-∞, +∞] 
39	Fix Step 2: Consulting False -ve Filter S6 S5 S2 S7 S4 S8 S1 S3 If S4  A(tc)  remove S4 from A(t) Select stream S7  A(tc) with [+∞, +∞] filter  If V7 [l, u], insert S7 into answer set install the [l, u] filter to S7 Prove that F +(tc) ≤ + and F -(tc) ≤ - are satisfied Worst case: 5 messages Filter [-∞, +∞] Filter [+∞, +∞] Range of Q = [l, u] 
40	Fix Step 2: Consulting False -ve Filter S6 S5 S2 S7 S4 S8 S1 S3 Filter [-∞, +∞] Filter [+∞, +∞] 
41	False +ve / -ve Filters Selection Heuristic 
