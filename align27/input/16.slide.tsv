0	Proactive Query Re-optimization by Çetin Meriçli 12.10.2005 
1	Overview Query Processing Query Optimization Idea Problems Solutions to problems in query optimization Reactive re-optimization Proactive Re-optimization RIO Implementation Details 
2	Query Processing A SQL statement is subjected to four phases of processing Parsing Optimization Code Generation Execution 
3	Query Optimization Same result set for a query can be obtained in more than one way. Depending on the query, different execution plans may have different costs. Query optimizers try to find an execution plan with the lowest cost for a given query based on some statistical estimations about the data.  
4	Query Optimization (cont’d) Traditional optimization follows a plan-first-execute-next approach This approach enumerates all execution plans, computes the cost of each plan and picks the plan with the lowest cost Performance highly depends on the accuracy of the estimated statistics used to compute costs 
5	Query Optimization (cont’d) Example: 		select * from R, S  		where R.a = S.a and  			   R.b > K1 and  			   R.c > K2 
6	Query Optimization (cont’d) Assume that DB Buffer cache size is 200 Mb |R| = 500 Mb |S| = 160 Mb | σ(R) | = 300 Mb Due to skew and correlations in the data, optimizer estimates | σ(R) | to be 150 Mb 
7	Query Optimization (cont’d) Two parts of the query S σ(R) (result of the selection on R ) P1a P1b 
8	Query Optimization (cont’d) Since | σ(R) | is underestimated, P1a is selected as the optimal plan, but P1b should have been selected by the optimizer since the estimation is wrong and P1a gets more costly for greater values of  | σ(R) | . 
9	Reactive Optimization Reactive optimizers works in the following way Use a traditional optimizer to find the best plan. Use check operators to detect sub-optimality during execution. Trigger re-optimization, if required. 
10	Problems with Reactive Re-optimization The optimizer may pick plans whose performance depends heavily on uncertain statistics, making re-optimization very likely The partial work done in a pipelined plan is lost when re-optimization is triggered and the plan is changed The ability to collect statistics both quickly and accurately during execution is limited  So, when re-optimization is triggered, the optimizer may make new mistakes, leading potentially to thrashing 
11	Proactive Re-optimization A novel approach Uses Bounding boxes instead of single point estimations to represent uncertainty Bounding boxes are used during optimization to generate robust and switchable plans, minimizing the need for re-optimization (hence, the loss of pipelined work) Random-sample processing is merged with query execution to collect statistics quickly and accurately 
12	Proactive Re-optimization 
13	Representing Uncertainty Most of the current optimizers uses single-point estimates of the statistics needed to cost plans Using intervals instead of single points allows the optimizer to handle uncertainty about the estimates As the confidence about the estimate increases, bounding box gets narrower 
14	Representing Uncertainty 
15	Using Bounding-boxes During Optimization  There is always one optimal plan for a single-point estimate For a bounding box B, following cases can occur: Single optimal plan: A single plan is optimal at all points within B Single robust plan: There is a single plan whose cost is very close to the optimal at all points in B A switchable plan: Explained in the next slide None of the above: Different plans are optimal at different points in B, but no switchable plan is available 
16	Switchable Plans A switchable plan in B is a set S of plans with the following properties At each point pt in B, there is a plan p in S whose cost at pt is close to that of the optimal plan at pt The decision of which plan in S will be executed can be deferred until accurate estimates of uncertain statistics are available  If the actual statistics lie within B, an appropriate plan from S can be picked and run without losing any significant fraction of the execution work done so far 
17	RIO Implementation Details Computing Bounding-boxes  Optimizing with Bounding-boxes Generating the Seed Plans Generating the Switchable Plan Extensions to Query Execution Engine Experiments 
18	Computing Bounding-boxes RIO restricts the computation of bounding boxes to size and selectivity estimates For each such estimate E,  a bounding box B is computed using the following process An uncertainty bucket U is assigned to E The bounding box is computed from the       (E, U) pair An integer domain [0,6] is assigned to U  according to some information (is there an accurate value of E exists in the catalog, etc..) from 0 (no uncertainty) to 6 (very high uncertainty) 
19	Optimizing with Bounding-boxes RIO computes bounding boxes for all input sizes used to cost plans Then it tries to compute a switchable plan for each distinct (JS, IO) pair (JS : Join Subset, IO : Interesting Orders ) If RIO fails to find a switchable plan, it picks the optimal plan based on single-point estimates 
20	Computing switchable plans RIO computes switchable plans in two steps First, it finds three seed plans for each (JS, IO) pair Then, it creates the switchable plan from the seed plans 
21	Generating seed plans In RIO, each enumeration for plans considers three different costs CLOW CEST CHIGH CEST is the traditional single-point estimation CLOW and CHIGH are lower left and upper right corners of the bounding box For each (JS, IO) pair, we end up with three seed plans BestPlanLow: plan with minimum cost CLOW BestPlanEst: plan with minimum cost CEST BestPlanHigh: plan with minimum cost CHIGH 
22	Generating the Switchable Plan Given the seeds BestPlanLow, BestPlanEst and BestPlanHigh, one of the following cases arises C1 : The seeds are all the same plan C2 : They are not the same, but one is a robust plan C3 : Neither they are the same, nor one is a robust plan, but, a switchable plan can be created from the seeds C4 : A single optimal plan, a single robust plan or a switchable plan cannot be found  
23	Generating the Switchable Plan (cont’d) In C1, the single optimal plan is the switchable plan In C2, RIO finds the robust plan among the seeds and uses it as a singleton switchable plan In C3, RIO tries to find a switchable plan (next slide) In C4, RIO picks BestPlanEst as the optimal plan 
24	Finding Switchable Plans RIO tries to find the set S of plans satisfying the following constraints by enumerating the seeds All plans in S have a different joint operator as the root operator All plans in S have the same subplan for the deep subtree input to the root operator All plans in S have the same base table, but not necessarily the same access path, as the other input to the root operator 
25	Using Switchable Plans Contrary to the single point optimization, it is seen that P1b is more robust since it has a cost near to the optimal at all points in bounding box. But, since two plans are switchable as long as |σ(R)| lies within the bounding box, it is preferable to select  P = {P1a, P1b} switchable plan instead of selecting P1b 
26	Extensions to Query Execution Engine Following extensions have been made in order to satisfy requirements of the proactive      re-optimization A switch operator for handling switchable plans A buffer operator for buffering the tuples until it can compute an input-size estimate needed by the switch operator Randomization-aware operators for performing random sampling for more accurate estimations of the statistics An inter-operator communication mechanism allowing operators to exchange estimates and random samples 
27	Experiments RIO has been tested with the following cases Two-way join queries Three-way join queries Correlation-based mistakes Thrashing More increased query complexity 
28	Results for two-way join queries experiments 
29	Results for three-way join queries experiments 
30	Results for correlation mistakes experiments 
31	Results for more increased query compexity experiments 
32	Conclusions Proactive re-optimization is a novel approach to query optimization RIO is a prototype that uses  Bounding boxes instead of single point estimates for handling uncertainty Switchable plans for reducing the loss in pipelined work Random sampling techniques for collecting statistics quickly and more accurately In the experiments, RIO outperforms the current re-optimizers by up to a factor of three 
33	References Babu, et. al, “Proactive Re-optimization” Babu and Bizarro, “Adaptive Query Processing in the Looking Glass” Selinger et. al, “Access Path Selection in a Relational Database Management System” 
34	Thanks…Any Questions? 
