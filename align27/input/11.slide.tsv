0	CMPE 521: PRINCIPLES OF DATABASE SYSTEMS AGILE: Adaptive Indexing for Context-Aware Information Filtres by  Jens-Peter Dittrich     Peter M. Fischer     Donald Kossmann Fall  2005 Presented by  Şerif BAHTİYAR  
1	Outline Introduction Problem Statement Context-Aware Information Filters State-of-the-Art Adaptive Indexing: AGILE Performance Experiments and Results  Conclusion  
2	Introduction Information filtering has become a key technology for modern information systems The goal of an information filter is to route messages to the right recipients (possibly none) according to declarative rules called profiles.  This paper presents AGILE, a way to extend existing index structures so that the indexes adapt to the message/update workload and show good performance in all situations.  The focus of all that work was on the development of scalable index structures in order to group and index profiles.  
3	Introduction A major shortcoming of the existing approaches is that they are very inefficient if profiles refer to values in a database that are subject to change.  This paper presents Context-aware Information Filters (CIF) Differences of CIF Has two input streams a stream of messages,   a stream of context updates Provides a unified solution to tailor information delivery  The challenge of building a CIF is to route messages and  record contex updates efficiently 
4	Introduction Use Cases for CIF Message broker with state: A message broker routes messages to a specific application and location.  Generalized location-based services: With an increased availability of mobile, yet network-connected devices, the possibilities for personalized information delivery have multiplied.  Stock brokering: Financial information systems require sending only the relevant market updates to specific applications or brokers.  
5	Introduction Contribution Summary Introduce the concept of a Context-Aware Information Filter Introduce a CIF-architecture in which intermediary filter stages are allowed to generate false positives as trade-in for higher update rates. To ensure correctness, false positives are eliminated in a separate post-filtering step  Presents the generic algorithm AGILE. This algorithm extends best-of-breed index structures to automatically adapt to high update rates The results of comprehensive performance experiments  
6	Problem Statement 	Given a large set of profiles, high message rates and varying rates of context updates, provide the best possible throughput of messages. No message must be dropped or sent to the wrong user because a change in context has not yet been considered by the filter. This constraint rules out methods that update the context only periodically. 
7	Problem Statement Context: a set of attributes associated with an entity; the values of those attributes can change at varying rates.  The only assumption that is made in this work is that the values of an attribute of a context can change and that these changes are triggered by a stream of context updates.  
8	Problem Statement Messages: A message is a set of attributes associated to values. 
9	Problem Statement Profiles: A profile is a continuous query specifying the information interests of a subscriber. Expressions in profiles can refer to a static condition or a dynamic context. Static conditions change relatively seldom In contrast, context information can change frequently.  
10	Context-Aware Information FiltersCIF Processing Model The CIF keeps profiles of subscribers and context information. The CIF receives two input streams: a message stream and a context update stream. These two streams are serialized so that at each point in time either one message or one update is processed. handle_message(Message m): Find all profiles that match the given message m, considering the current context state.  update_context(Context c,Attribute a,Value v): Set the attribute a of context c to the new value v, i.e. c.a := v. All profiles referencing this context must consider this new value.  
11	Context-Aware Information FiltersCIF Architecture A CIF has four main components. 
12	Context-Aware Information FiltersCIF Architecture Context management:  manages context information. stores the values of static attributes and values of context attributes which are used in predicates of profiles any context change is recorded by this component interacts heavily with indexes and postfiltering  
13	Context-Aware Information FiltersCIF Architecture Indexes: filtering can be accelerated by indexing the profiles or predicates of the profiles.  The most important method supported by an index is probe, which is invoked by the CIF’s handle_message method. probe takes a message as input and returns a set of profiles that potentially match that message.  An index can be classified by four different aspects: Target (value index or structure index) Accuracy (exact index or fuzzy index): probing can result false positive Dimensionality (single index or several index) Scope (full index or partial index) The key idea to implementing adaptive context-aware information filters is to control the accuracy and scope of indexes. 
14	Context-Aware Information FiltersCIF Architecture Merge: takes several intermediate result sets of profiles as input and carries out conjunctions and disjunctions on those sets of predicates 
15	Context-Aware Information FiltersCIF Architecture Postfilter: eleminates false positives. In other words, it takes a set of profiles as input and checks which profiles match the message by reevaluating the predicates of the profiles based on the current state of the context.  
16	State-Of-the-ArtNo Index The brute-force approach is to use no index at all. All the work is carried out in the postfilter operation.  The main advantage is the update_context operation is cheap. Negative side, the handle_message operation is expensive because the postfilter operation is applied to all profiles.  
17	State-Of-the-ArtEager Full Indexing The opposite to the NOINDEX approach is an approach that makes aggressive use of indexes and keeps all indexes uptodate and 100 percent accurate. The big advantage of EAGER is that the handle_message operation is as cheap. The big disadvantage of the EAGER approach is that the update_context operation is expensive because it involves maintaining indexes, potentially with every context update.  
18	State-Of-the-ArtEager Full Indexing 
19	State-Of-the-ArtPartial Indexing The idea of partial indexes is to reduce the cost of the update_context operation by reducing the scope of an index.  If an update is outside the scope of an index, then the index need not be updated. All non-indexed values must be processed in a brute-force manner. The most important issue is how to define the scope of a partial index. 
20	State-Of-the-ArtLazy Updates, GBU Lately, there has been work on moving object databases and the basic insight of that work is that updates often exhibit a high degree of locality.  The idea is that updates that remain within the bounding box of a leaf node of an index are not propagated to non-leaf nodes of the index; propagation only occurs if the new value is outside of the bounding box of the old value. If propagation is necessary, then locality is also exploited as much as possible. 
21	Adaptive Indexing:AGILEGeneral Idea The key idea of AGILE is to dynamically reduce the accuracy and scope of an index if context updates are frequent and to increase the accuracy and scope of an index if context updates are seldom and handle_message calls are frequent.  The operation to reduce the accuracy is called escalation  The operation that increases the accuracy of an index is called deescalation 
22	Adaptive Indexing:AGILEGeneral Idea - Example In order to implement AGILE on a binary tree, the structure of a node is extended. In addition to the key k, every node has three sets of identifiers:  left: this is a set of escalated identifiers (i.e., profiles)  which are associated with the key range ] −  , k[ right: this is a set of escalated identifiers (i.e., profiles) which are associated with the key range ]k,+    [  exact: the set of non-escalated identifiers which are associated with k 
23	Adaptive Indexing:AGILEGeneral Idea – Example Escalation Figure 5 shows how an identifier, A, is escalated. This operation is triggered by increasing the stock of Warehouse A by one; i.e., a context update from two to three. 
24	Adaptive Indexing:AGILEGeneral Idea – Example Cheap Update The index need not be adjusted at all in order to reflect this change and, thus, the update_context operation is as cheap as for the NOINDEX approach in this case.  
25	Adaptive Indexing:AGILEGeneral Idea – Example Deescalation It is triggered if the handle_message operation is called several times for orders and Warehouse A was returned by the index as a potential candidate and had to be filtered out by the postfilter step. Deescalating from a left or right set of a leaf node involves inserting a new leaf node and moving the identifier into the exact set of this new node.  
26	Adaptive Indexing:AGILEProperties of AGILE Indexes Formally, every index maps each key k to a set of identifiers {i}. This mapping is returned by the probe operation of an index, i.e. probe(k) ->{i}.  
27	Adaptive Indexing:AGILEAGILE Algorithm 
28	Adaptive Indexing:AGILEAGILE Indexes – AGILE Interval Skip Lists (ISL) An ISL is a hierarchical index structure that is applicable to all ordered domains (e.g., numerical values, dates).  Each identifier of a profile is associated with one or more ranges of values. Furthermore, each range is associated with a set of identifiers. Ranges are organized hierarchically so that all ranges covering a given value can be found more quickly (logarithmic complexity in the average case)  
29	Adaptive Indexing:AGILEAGILE Indexes – AGILE Interval Skip Lists (ISL) 
30	Adaptive Indexing:AGILEAGILE Indexes – Other AGILE Index Structures Hash Table: An escalation is implemented by associating an identifier with the whole domain of values. Effectively, this means deleting the identifier from the hash table and keeping it in a separate list of identifiers that are returned for every probe. Deescalations are implemented by re-inserting the identifier into the hash table and deleting it from the escalate list.  B-Tree, B+-Tree,R-Tree: Logically, an escalation is implemented by moving an identifier into the buffer of its parent. Deescalations are implemented by moving an identifier to a child node. 
31	Adaptive Indexing:AGILEAGILE Indexes –  Deescalation Policies Ideally, an index should be deescalated if the cost for the deescalation is lower than the cost of eliminating false positives in the postfilter step of future handle message operations. Some simple heuristics Always : Every false positive encountered by the postfilter triggers a deescalation. Fixed: A fixed number of false positives FP is ignored until a deescalation is performed.  Auto : auto operates like fixed and ignores a certain number of false positives FP before a deescalation is triggered.  
32	Performance Experiments and Results Software  and Hardware used In order to implement the individual components, the following design choices were made: Context Management Indexes Merge Postfilter All software was implemented in C++. All experiments were performed on a 3.2 GHz Pentium 4 machine with 2 GB of RAM running Linux 2.4.  
33	Performance Experiments and Results Workload When selecting the workloads to test the different methods, researchers followed the requirements derived from the Use Cases. The number of profiles is high, most profiles refer to contexts. Low, high and varying context update rates are studied.  
34	Performance Experiments and Results Experiment 1:Throughput in Steady State Figure 11 shows the relative throughput, normalized to the throughput of AGILE. Table 3 shows the absolute throughput results. 
35	Performance Experiments and Results Experiment 1:Throughput in Steady State A more detailed understanding of these results can be gained by looking at the number of executed index updates (Table 4) and the number of profiles that need to be inspected in the postfilter operation (Table 5).  
36	Performance Experiments and Results Experiment 2: Vary UpdAtt The experiment studies the impact of varying the distribution of updates to indexed and non-indexed attributes (UpdAtt). Figure 12 shows the total time used to execute a workload of 10.000 messages and 500 Mio. updates (UP=1000). 
37	Performance Experiments and Results Experiment 3: Vary ∆U Both GBU and AGILE take advantage of the locality of context updates.  Figure 13 shows the completion time for varying ∆U from very high update locality (∆ U close to 0) to very low update locality (∆ U = 2,500 which is 25 percent of the whole scope of possible attribute values).  
38	Performance Experiments and Results Experiment 4:Update Burst Figure 14 shows the throughput at different moments in time; the throughput is computed for every batch of 100 messages. It can be seen that the message throughput drops during the update burst (between Message 1,000 and Message 2,000) 
39	Performance Experiments and Results Experiment 4:Update Burst Figure 15 and Table 6 show how alternative deescalation strategies fare in this experiment. Indeed, auto outperforms fixed in this experiment, but the differences are not large.  
40	Conclusion Information filtering has matured to a key information processing technology. This work provides simple extensions to existing index structures for information filtering systems.  The key idea is to adapt the accuracy and scope of an index to the workload of a context-aware information filter. Improve the message throughput of a context-aware information filter Robust to poor physical design  Can gradually adjust to changes in the locality of updates  Is able to deal with workloads with bursts  
41	QUESTIONS ? 
