0	Conceptual Partitioning: An Efficient Method for Continuous Nearest Neighbour Monitoringby Kyriakos Mouratidis, Marios Hadjieleftheriou and Dimitris PapadiasJune, 2005 presented by Meltem Yıldırım Boğaziçi University, 2005 
1	Agenda Problem Solution: Conceptual Partitioning Monitoring (CPM) Extensions of the Solution Performance Analysis Conclusion 
2	What is the Problem? Problem:  	continously monitoring the nearest neighbours of certain objects in a dynamic environment Some Wireless Mobile Applications: Fleet management, location-based services  A set of moving objects  A central server that  monitors their positions over time processes continuous queries from geographically distributed clients  reports up-to-date results  Naive approach: the server constantly obtains the most recent position of all objects transmission of a large number of rapid data streams corresponding to location updates 
3	Purpose (formal) Spatial Data: data with position information (location, shape, size, relationships to other entities) Spatial Query: querying objects based on their geometry P = {p1, p2, …, pn}  → set of objects 	q: a query point  	k-NN query: k nearest neighbour query which retrieves the k objects in P that lie closest to q  The problem is well studied for static datasets but not for highly-dynamic environments with continuous multiple queries  q p1 p2 p3 p4 p5 p6 
4	Related Work Methods focusing on range query monitoring:  	Q-index, MQM, Mobieyes, SINA 	It is almost impossible to extend them to NN queries Methods that explicitly target NN processing:  	DISC, YPK-CNN, SEA-CNN  
5	CPM – Conceptual Partitioning Monitoring 2D data objects and queries that change their location frequently and in an unpredictable manner An update from object p is a tuple  	<p.id, xold, yold, xnew, ynew> A central server receives the update stream and continuosly monitors the k NNs of each query q Grid index Each cell is δxδ 
6	CPM – Conceptual Space Partitioning Each rectangle has direction level number For rectangles DIRj and DIRj+1,  	mindist(DIRj+1,q) = mindist(DIRj, q) + δ CPM visits cells in ascending mindist(c, q) order 
7	CPM – Data Structures 
8	CPM – NN Computation Module initialize an empty heap ,	best_dist = ∞ 	and best_NN = Ø, visit_list = Ø insert the following into H <cq, 0> <DIR0, mindist(DIR0, q)> repeat: Get the next entry of H If it is a cell, For each pЄc, update best_NN and best_dist if necessary insert an entry for q into the influence list of c insert <c, mindist(c, q)> at the end of the visit_list Else For each cell c in DIR, insert <c, mindist(c, q)> into H Insert the next-level rectangles into H 	until H is empty or the next entry in H has  	mindist ≥ best_dist 
9	CPM - Example Heap empty and ignored enheap the cells of U0 and the rectangle U1 enheap the cells of L0 and the rectangle L1 …we come across p1 Є c3,3 best_dist = dist(p1, q) = 1.7 …we come across p2 Є c2,4 best_dist= dist(p2, q) = 1.3 …we come across c5,6 since  mindist(c5,6, q) ≥ best_dist 
10	CPM – Handling a Single Object Update When p moves from cold to cnew Delete p from cold and scan the influence_list of cold if p Є q.best_NN and dist(p, q) ≤ best_dist → reorder best_NN if p Є q.best_NN and dist(p, q) > best_dist → mark q as affected Add p into cnew and scan the influence_list of cnew if dist(p, q) < q.best_dist remove the current kth NN from q.best_NN insert p into q.best_NN update q.best_dist Re-compute the best_NN of every affected query (sequential processing of visit_list and H) 
11	CPM – Handling Multiple Object Updates O: set of outgoing objects I: set of incoming objects I U best_NN – O If |I| ≥ |O| influence region of q includes at least k objects new best_NN can be formed easily without invoking recomputation Scan visit_list and look for where 	best_distnew < mindist(c, q) < best_distold 
12	CPM – Handling Query Updates When a query is terminated Delete its entry from QT Remove it from the influence lists of the cells in its influence region When a new query is inserted NN Computation Algorithm When a query moves Termination + Insertion 
13	Aggregate NN Queries - SUM Q = {q1, q2, …, qm} Find p minimizing ∑qiЄQ dist(p,q) Difference:  rectangle M containing all qi Є Q enheap all the cells intersecting M 
14	Aggregate NN Queries – MIN Q = {q1, q2, …, qm} Find objects with the smallest distance(s) from any query in Q 
15	Constrained NN Queries Only cells or rectangles intersecting the constraint region are added to the heap 
16	Performance Analysis Cell size: δ↑ Cells consume more space, object_list↑, influence_list↑ higher number of processed objects δ↓ High overhead due to heap operations 
17	Evaluation by Simulation Roadmap of Oldenburg Set of temporary objects (cars, pedestrians, etc.) and persistent NN queries Default velocity values: slow, medium, fast Comparison by YPK-CNN and SEA-CNN System Parameters 
18	CPU time v.s. Grid Granularity 
19	CPU time v.s. N and n  
20	Performance v.s. k 
21	CPU time v.s. Object and Query Speed  
22	CPU time v.s. Object and Query Agility  
23	CPU time for Constantly Moving and Static Queries  
24	Conclusion investigating the problem of monitoring continuous NN queries over moving objects CPM: Low running time due to the elimination of unnecessary computations Makes use of visit_list and heap for recomputations Extending framework (aggregate, constrained NN queries) Performance evaluation 
25	Questions? 
26	Q-index Assumes static range queries over moving objects Queries are indexed by an R-tree 	R-tree: splits space with hierarchically nested, and possibly overlapping, boxes  Each object p is assigned a region such that p needs to issue an update only if it exits this area  Moving objects probe the index to find the queries that they influence 
27	YPK-CNN Objects are indexed with a regular grid of cells where each cell is δxδ Updates are not processed as they arrive, each query is re-evaluated every T time units The first evaluation of a query q: visit the cells in a square R around the cell cq covering q until k objects are found d = distance(q, kth NN object) Search cells intersecting with square SR centered at cq with side length 2d + δ Re-evaluation of a query q: 	dmax: distance of the previous neighbour that moved furthest  	new SR: square centered at cq with side length 2·dmax+ δ  When q changes location, it is handled as a new one R SR d SR 
28	SEA-CNN No module for the first evaluation of a query q best_dist: distance between q and the kth NN answer region of a query q: circle with center q  and radius best_dist The cells intersecting the answer region of q hold book-keeping information to indicate this fact Determines a circular region SR around q and computes the new k NN set of q  
29	Aggregate NN Queries - MAX Q = {q1, q2, …, qm} Find objects with the lowest maximum distance(s) from any query in Q 
